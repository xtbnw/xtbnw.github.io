<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>哈夫曼树原理、应用和实现 | xtbn's blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 7.3.0"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">xtbn's blog</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>哈夫曼树原理、应用和实现</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2024-12-03</div></div></div><article><div class="container post"><p>简单介绍哈夫曼树这种树结构的原理、应用和实现</p>
<span id="more"></span>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>如果给二叉树的每个<em>叶子结点</em>都赋一个权值，则根结点到各叶子结点的路径长度乘上对应叶子结点的权值之和就是该二叉树的<em>带权路径长度</em>，即WPL&#x3D;W1* L1+W2* L2+···+Wn* Ln。<br>则给定一组具体确定权值的叶子节点，可以构造出形态各异的二叉树，其中具有<em>最小带权路径长度</em>的二叉树就叫哈夫曼树，也称为<em>最优二叉树</em></p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>根据哈夫曼树的定义，如果要使WPL值最小，一般权值越大的叶子结点要越靠近根结点</p>
<ol>
<li>从所有叶子节点里选择权值最小的两个，权值相加作为它们的父结点</li>
<li>然后从原来的叶子结点集合里面忽略（删去）刚才操作的两个权值最小的结点，将它们的父结点加入这个集合</li>
<li>循环步骤1，直到集合中只剩下一个结点为止，这个结点就是根结点，这样构造好的树就是哈夫曼树</li>
</ol>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>哈夫曼树在编码问题中有着应用</p>
<h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><p>比如传送一串电文“AABBAAABDDCCCDDABDDDCC”，这段电文只有4个字符ABCD，所以可以用00、01、10、11的二进制编码表示。但是在传送时人们希望电文长度尽可能短以缩短传送时间。<br>如果我们以0、1、10、01分别作为ABCD的编码，则能缩短电文的二进制长度，但是这样就无法正确解码（比如对于10，不能准确知道它是BA还是C），这样的编码不是前缀码，因此无法唯一解码。</p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>想要得到正确且最短的编码，可以利用哈夫曼编码，还是以上面的电文为例</p>
<ol>
<li>将电文中每个字符都作为一个叶子结点，各字符的出现次数作为其叶子结点的权值</li>
<li>根据哈夫曼树的构造方法建立哈夫曼树</li>
<li>规定哈夫曼树的左分支为0，右分支为1，则从根结点到相应叶子节点所经过的路径分支组成的0和1的序列就是该叶子结点对应字符的哈夫曼编码<br>哈夫曼编码是种前缀编码，解码时不会混淆</li>
</ol>
<h2 id="结点模板"><a href="#结点模板" class="headerlink" title="结点模板"></a>结点模板</h2><p>因为编码时要能找到父结点，所以需要采用三叉链表或<em>双亲-孩子法（一种顺序存储）</em><br>这里以双亲-孩子法为例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> WeightType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    WeightType weight; <span class="comment">// 权重</span></span><br><span class="line">    <span class="type">int</span> parent, left, right;</span><br><span class="line">    <span class="built_in">HuffmanTreeNode</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        parent = left = right = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">HuffmanTreeNode</span>(WeightType w, <span class="type">int</span> p = <span class="number">-1</span>, <span class="type">int</span> l = <span class="number">-1</span>, <span class="type">int</span> r = <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        weight = w;</span><br><span class="line">        parent = p;</span><br><span class="line">        left = l;</span><br><span class="line">        right = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="哈夫曼树模板"><a href="#哈夫曼树模板" class="headerlink" title="哈夫曼树模板"></a>哈夫曼树模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharType, <span class="keyword">typename</span> WeightType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuffmanTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    HuffmanTreeNode&lt;WeightType&gt; *nodes;<span class="comment">//存放所有结点</span></span><br><span class="line">    CharType *LeafChars;<span class="comment">//存放电文中的字符</span></span><br><span class="line">    String *LeafCharCodes;<span class="comment">//存放字符的编码</span></span><br><span class="line">    <span class="type">int</span> num;<span class="comment">//叶子结点数目</span></span><br><span class="line">    <span class="comment">// 辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> &amp;l1, <span class="type">int</span> &amp;l2)</span></span>;<span class="comment">//从前n个结点里面选择最小的两个叶子结点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateHuffmanTree</span><span class="params">(WeightType *w, CharType *c, <span class="type">int</span> n)</span></span>;<span class="comment">//构造哈夫曼树</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HuffmanTree</span>(WeightType *w, CharType *c, <span class="type">int</span> n);</span><br><span class="line">    <span class="built_in">HuffmanTree</span>(<span class="type">const</span> HuffmanTree&lt;CharType, WeightType&gt; &amp;h);</span><br><span class="line">    HuffmanTree&lt;CharType, WeightType&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> HuffmanTree&lt;CharType, WeightType&gt; &amp;h);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">HuffmanTree</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="function">String <span class="title">Encode</span><span class="params">(CharType ch)</span></span>;                  <span class="comment">// 取ch的编码</span></span><br><span class="line">    <span class="function">LinkedList&lt;CharType&gt; <span class="title">Decode</span><span class="params">(String strCode)</span></span>; <span class="comment">// 解码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>存放字符的数组和存放字符编码的数组下标一一对应，且所有结点数组里面前num个存放的是所有的叶子节点，这些结点的下标与前两者也是一一对应的，他们的长度都是num，换言之，只要确定了其一的下标，就能知道另外两个元素</li>
<li>所有结点的数目是叶子节点的2倍-1，即<code>nodesnum=2*num-1</code></li>
</ul>
<h3 id="函数实现示例"><a href="#函数实现示例" class="headerlink" title="函数实现示例"></a>函数实现示例</h3><h4 id="选择两个最小权值叶子节点"><a href="#选择两个最小权值叶子节点" class="headerlink" title="选择两个最小权值叶子节点"></a>选择两个最小权值叶子节点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharType, <span class="keyword">typename</span> WeightType&gt;</span><br><span class="line"><span class="type">void</span> HuffmanTree&lt;CharType, WeightType&gt;::<span class="built_in">Select</span>(<span class="type">int</span> n, <span class="type">int</span> &amp;l1, <span class="type">int</span> &amp;l2)</span><br><span class="line">&#123;<span class="comment">//即从n个数中选择两个最小的数的算法</span></span><br><span class="line">    l1 = l2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[i].parent != <span class="number">-1</span>) <span class="comment">// 父节点不为-1，说明已经合并</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="number">-1</span>)</span><br><span class="line">            l1 = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nodes[i].weight &lt; nodes[l1].weight)</span><br><span class="line">        &#123;</span><br><span class="line">            l2 = l1;</span><br><span class="line">            l1 = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="number">-1</span> || nodes[i].weight &lt; nodes[l2].weight)</span><br><span class="line">            l2 = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h4><ol>
<li>初始化叶子节点</li>
<li>构造哈夫曼树</li>
<li>编码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharType, <span class="keyword">typename</span> WeightType&gt;</span><br><span class="line"><span class="type">void</span> HuffmanTree&lt;CharType, WeightType&gt;::<span class="built_in">CreateHuffmanTree</span>(WeightType *w, CharType *c, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    num = n;                                    <span class="comment">// 叶子节点数</span></span><br><span class="line">    <span class="type">int</span> nodesnum = n * <span class="number">2</span> - <span class="number">1</span>;                   <span class="comment">// 节点数</span></span><br><span class="line">    nodes = <span class="keyword">new</span> HuffmanTreeNode&lt;WeightType&gt;[n]; <span class="comment">// 创建节点数组</span></span><br><span class="line">    LeafChars = <span class="keyword">new</span> CharType[n];                <span class="comment">// 创建字符数组</span></span><br><span class="line">    LeafCharCodes = <span class="keyword">new</span> String[n];              <span class="comment">// 创建字符编码数组</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123; <span class="comment">// 初始化叶子节点</span></span><br><span class="line">        nodes[i].weight = w[i];</span><br><span class="line">        nodes[i].left = <span class="number">-1</span> nodes[i].right = <span class="number">-1</span>;</span><br><span class="line">        nodes[i].parent = <span class="number">-1</span>;</span><br><span class="line">        LeafChars[i] = c[i];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; nodesnum; i++)</span><br><span class="line">    &#123; <span class="comment">// 创建哈夫曼树，按照哈夫曼树的构造规则，构造出来的父结点按顺序依次存储</span></span><br><span class="line">        <span class="type">int</span> l1, l2;</span><br><span class="line">        <span class="built_in">Select</span>(i, l1, l2);</span><br><span class="line">        nodes[l1].parent = nodes[l2].parent = i;</span><br><span class="line">        nodes[i].weight = nodes[l1].weight + nodes[l2].weight;</span><br><span class="line">        nodes[i].left = l1;</span><br><span class="line">        nodes[i].right = l2;</span><br><span class="line">        nodes[i].parent = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> p, q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;<span class="comment">//编码</span></span><br><span class="line">        LinkedList&lt;<span class="type">char</span>&gt; charCode; <span class="comment">// 暂存编码，用的是前面的api</span></span><br><span class="line">        q = i;<span class="comment">//从叶子结点开始向上追溯</span></span><br><span class="line">        p = nodes[i].parent;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodes[p].left == q)</span><br><span class="line">                charCode.<span class="built_in">InsertElem</span>(<span class="number">1</span>, <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 不断插到首部，则最后得到的编码是正确顺序</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                charCode.<span class="built_in">InsertElem</span>(<span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            q = p;<span class="comment">//继续向上追溯</span></span><br><span class="line">            p = nodes[p].parent;</span><br><span class="line">        &#125;</span><br><span class="line">        LeafCharCodes[i] = charCode; <span class="comment">// 左值是自定义String类型，右值是LinkedList&lt;char&gt;类型，String类型有可以接受LinkedList的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><ul>
<li>复制结点、字符和字符编码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharType, <span class="keyword">typename</span> WeightType&gt;</span><br><span class="line">HuffmanTree&lt;CharType, WeightType&gt; &amp;HuffmanTree&lt;CharType, WeightType&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> HuffmanTree&lt;CharType, WeightType&gt; &amp;h)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;h)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] nodes;</span><br><span class="line">    <span class="keyword">delete</span>[] LeafChars;</span><br><span class="line">    <span class="keyword">delete</span>[] LeafCharCodes;</span><br><span class="line">  </span><br><span class="line">    num = h.num;</span><br><span class="line">    nodesnum = num * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    nodes = <span class="keyword">new</span> HuffmanTreeNode&lt;WeightType&gt;[nodesnum];</span><br><span class="line">    LeafChars = <span class="keyword">new</span> CharType[num];</span><br><span class="line">    LeafCharCodes = <span class="keyword">new</span> String[num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nodesnum; i++)</span><br><span class="line">        nodes[i] = h.nodes[i];<span class="comment">//复制所有结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;<span class="comment">//复制字符和字符编码</span></span><br><span class="line">        LeafChars[i] = h.LeafChars[i];</span><br><span class="line">        LeafCharCodes[i] = h.LeafCharCodes[i];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="取编码"><a href="#取编码" class="headerlink" title="取编码"></a>取编码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharType, <span class="keyword">typename</span> WeightType&gt;</span><br><span class="line">String HuffmanTree&lt;CharType, WeightType&gt;::<span class="built_in">Encode</span>(CharType ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        <span class="keyword">if</span> (LeafChars[i] == ch)<span class="comment">//找到对应的字符下标</span></span><br><span class="line">            <span class="keyword">return</span> LeafCharCodes[i];<span class="comment">//因为下标一一对应</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解码字符串"><a href="#解码字符串" class="headerlink" title="解码字符串"></a>解码字符串</h4><ul>
<li>从根节点（下标<code>2*num-2</code>）开始向下按照编码字符串01选择向左还是向右，每次到达叶子节点都向解码结果中插入对应叶子节点的字符，然后回到根节点重新向下查找<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharType, <span class="keyword">typename</span> WeightType&gt;</span><br><span class="line">LinkedList&lt;CharType&gt; HuffmanTree&lt;CharType, WeightType&gt;::<span class="built_in">Decode</span>(String strCode)</span><br><span class="line">&#123;</span><br><span class="line">    LinkedList&lt;CharType&gt; result; <span class="comment">// 解码结果</span></span><br><span class="line">    <span class="type">int</span> p = <span class="number">2</span> * num - <span class="number">2</span>;         <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strCode.<span class="built_in">GetLength</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (strCode[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            p = nodes[p].left; <span class="comment">// 向左分支</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = nodes[p].right;                          <span class="comment">// 向右分支</span></span><br><span class="line">        <span class="keyword">if</span> (nodes[p].left == <span class="number">-1</span> &amp;&amp; nodes[p].right == <span class="number">-1</span>) <span class="comment">// 到达叶子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">InsertElem</span>(result.<span class="built_in">GetLength</span>() + <span class="number">1</span>, LeafChars[p]); <span class="comment">// 叶子节点对应的字符</span></span><br><span class="line">            p = <span class="number">2</span> * num - <span class="number">2</span>;                                         <span class="comment">// 回到根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">2</span> * num - <span class="number">2</span>) <span class="comment">// 确保解码成功，如果最后p没有回到根节点，说明编码格式不正确</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&quot;解码失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2024 <a href="/" rel="nofollow">xtbn</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>