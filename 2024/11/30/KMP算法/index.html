<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>KMP算法 | xtbn's blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 7.3.0"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">xtbn's blog</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>KMP算法</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2024-11-30</div></div></div><article><div class="container post"><p>一种高效查找定位子串的算法</p>
<span id="more"></span>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>实际上是每次重新匹配都结合上一次匹配的情况，跳过了不可能匹配的位置，直接从可能匹配的位置开始匹配，避免了主串下标的回溯，比如：（s位主串，t为模式串）<br><em>ps：真子串指在串中重复出现的、*<em>第一个元素与模式串首元素相同、最后一个元素与模式串当前位置尾-1元素相同（即公共前后缀）</em></em> 的子串，比如abceabc中abc出现了两次且abc中的a与模式串abceabc的首元素相同，abc就是个真子串；又比如bcaefcae，虽然cae出现了两次，但是串首元素是b，所以它不是真子串。（注意：真子串是可以有重叠的，比如aabbcaabbcaabb中aabbcaabb就是重叠的）*</p>
<ol>
<li>当模式串不包含真子串时：记<code>s[i]</code>，<code>t[j]</code>分别为主串和模式串当前正在匹配的位置的字符，<code>s[flag]</code>表示当前匹配是从主串的flag位置开始的，若匹配失败（即<code>s[i]!=t[j]</code>）<img src="/images/kmp%E7%AE%97%E6%B3%951.png" alt="kmp算法1"> 那么无需像朴素模式匹配算法一样从主串下一位<code>s[flag+1]</code>重新开始依次比较，因为模式串首元素<code>t[0]</code>与后面的元素<code>t[1],t[2]···</code>都不相同（因为没有真子串），又因为串首后面的元素与主串元素一一对应<code>t[1]==s[flag+1]，t[2]==s[flag+2]</code>，所以<code>t[0]</code>与主串当前失败位置前面的字符肯定不匹配，直接跳到主串当前匹配失败位置重新开始匹配，即比较<code>t[0]</code>和<code>s[i]</code>即可，如下图：<img src="/images/kmp%E7%AE%97%E6%B3%952.png" alt="kmp算法2"></li>
<li>若模式串包含真子串，比如abcabf（包含真子串ab）：<img src="/images/kmp%E7%AE%97%E6%B3%953.png" alt="kmp算法3">那么下一次需要跳到当前匹配失败位置的上一个真子串对应的主串位置，并从<em>模式串中第一个真子串结束的位置</em>开始匹配比较：<img src="/images/kmp%E7%AE%97%E6%B3%954.png" alt="kmp算法4"><br>可以看到<em>自始至终我们的主串下标 i 值是不回溯的，回溯的只有 j</em> ，而 j 的回溯规律又可以由模式串本身得到，<em>当 t 不包含真子串时，t 每次都从串首与 s 的 i 位置开始匹配；当 t 包含真子串时，看最长公共前后缀的长度 l，t 就从串首加 l 处开始匹配</em><br>我们可以把模式串在各个位置匹配失败时重新匹配的 j 值定义成一个数组<code>next[j]</code>，这个next数组的长度就等于模式串的长度，<code>next[j]</code>的函数如下：<br><code>next[j]=</code><br> -1，当j&#x3D;1时<br> max{k|0&lt;k&lt;j且<code>&quot;t[0]t[1]···t[k-1]&quot;==&quot;t[j-k]···t[j-1]&quot;</code>}，即有真子串情况<br> 0，无真子串情况<br>下面举些推导<code>next[j]</code>的实例：</li>
</ol>
<table>
<thead>
<tr>
<th><strong>下标 j</strong></th>
<th>0  1  2 3 4 5</th>
<th></th>
<th>0  1  2 34 5</th>
<th></th>
<th>0  1 2 3 4 5 67 8</th>
</tr>
</thead>
<tbody><tr>
<td><strong>模式串</strong></td>
<td>a  b  c  d e x</td>
<td></td>
<td>a  b c a b x</td>
<td></td>
<td>a  b a b a a  ab a</td>
</tr>
<tr>
<td><strong><code>next[j]</code></strong></td>
<td>-1 0 0 0 0 0</td>
<td></td>
<td>-1 0 0 0 1 2</td>
<td></td>
<td>-1 0 0 1 2 3 1 1 2</td>
</tr>
</tbody></table>
<p><em>可以看到<code>next[j]</code>其实就是当前位置前子串的最长公共前后缀长度</em></p>
<p>注意：kmp算法仅当模式串与主串之间存在许多“部分匹配”的情况下才体现出优势，否则两者差异不明显</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(<span class="type">const</span> String &amp;pat, <span class="type">int</span> *next)</span><span class="comment">//求next数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;<span class="comment">//首位赋-1，方便后面主串索引递增</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; pat.<span class="built_in">GetLength</span>() - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || pat[j] == pat[k])</span><br><span class="line">            next[++j] = ++k;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            k = next[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP_find</span><span class="params">(<span class="type">const</span> String &amp;ob, <span class="type">const</span> String &amp;pat, <span class="type">int</span> p = <span class="number">0</span>)</span><span class="comment">//KMP算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *next = <span class="keyword">new</span> <span class="type">int</span>[pat.<span class="built_in">GetLength</span>()];</span><br><span class="line">    <span class="built_in">GetNext</span>(pat, next);</span><br><span class="line">    <span class="type">int</span> i = p, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; ob.<span class="built_in">GetLength</span>() &amp;&amp; j &lt; pat.<span class="built_in">GetLength</span>() &amp;&amp; pat.<span class="built_in">GetLength</span>() - j &lt; ob.<span class="built_in">GetLength</span>() - i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || ob[i] == pat[j])<span class="comment">//如果匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];<span class="comment">//j回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] next;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= pat.<span class="built_in">GetLength</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li><code>GetNext</code>方法中，<code>k==-1</code>的赋值和判断条件是为了让串首不匹配时主串索引能递增，同理KMP算法里的<code>j=next[j]</code>也是一样作用</li>
<li><code>GetNext</code>方法中，<code>k=next[k]</code>一句是为了最长公共前后缀匹配失败时，下次k不是从头开始匹配，而是和第二种含真子串的方法一样，从次长公共前后缀处开始匹配，比如：<img src="/images/kmp%E7%AE%97%E6%B3%955.png" alt="kmp算法5">当前<code>pat[k]!=pat[j]</code>，所以<code>k=next[k]=next[4]=1</code><img src="/images/kmp%E7%AE%97%E6%B3%956.png" alt="kmp算法6">此时<code>pat[k]==pat[j]</code>，所以<code>next[++j]=++k=2</code><img src="/images/kmp%E7%AE%97%E6%B3%957.png" alt="kmp算法7"></li>
<li><code>GetNext</code>方法的复杂度是O(m)，kmp算法中while的复杂度是O(n)，整个算法的复杂度是O(m+n)</li>
</ul>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>我们目前的kmp算法还是有缺陷的，比如：<img src="/images/kmp%E7%AE%97%E6%B3%958.png" alt="kmp算法8">此时第五位不匹配，那么根据上面的<code>next[k]</code>，下一次应该跳到<code>j=3</code>处：<img src="/images/kmp%E7%AE%97%E6%B3%959.png" alt="kmp算法9">可以看到其实还是不匹配的，再跳到 j&#x3D;2,1,0都是不匹配，为什么？因为我们前面的字符和当前不匹配的字符都是a，既然当前字符不匹配那么前面字符肯定不匹配，这都是无用比较，所以我们要优化算法，如果当前字符与前缀字符相同，就用前缀字符的<code>next[k]</code>赋给当前字符的next值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(<span class="type">const</span> String &amp;pat, <span class="type">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; pat.<span class="built_in">GetLength</span>() - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || pat[j] == pat[k])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">if</span> (pat[j] == pat[k])<span class="comment">//如果当前字符与前缀字符相同</span></span><br><span class="line">                next[j] = next[k]; <span class="comment">// 将前缀字符的值直接赋给当前字符，跳过无用比较</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next[j] = k;<span class="comment">// 否则，将当前字符的next值设为k</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            k = next[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2024 <a href="/" rel="nofollow">xtbn</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>